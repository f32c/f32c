.TH BASIC 1
.SH DESCRIPTION
.I Rabbit BASIC
is an interpreter for a dialect of the BASIC programming language
loosely modelled around the historic Dartmouth BASIC.
The interpreter operates either in interactive mode, which permits
issuing individual commands or editing the current program, or
in run mode, executing the program loaded into the main memory.
At startup, the interpreter attempts to load and execute a program
called
.I autoexec.bat
from the root directory of the on-board Flash drive.
If the startup program can not be found or its execution terminates,
an interactive line editor is invoked which accepts and processes
all subsequent input from the controlling terminal.
.SH INTERACTIVE MODE
All lines prepended with a numeric line identifier are assumed
to be a part of a program and will be stored into the main memory at a
position corresponding to the specified line number, and will not be
further evaluated or interpreted until program execution begins.
Conversely, lines entered without a line number will be interpreted and
executed immediately.

Editing a line may be aborted at any time by pressing
.IR <ctrl-C> .
The contents of the line buffer may be redrawn by pressing
.IR <ctrl-R>
which can come handy particularly when editing lines longer then
terminal width (usually 80 characters).
Characters at the end of the line may be deleted
by pressing either the delete key or
.IR <ctrl-H> .
Neither cursors nor other
special keys, such as Home, End, PgUp or PgDown can be used in
editing mode, since mapping of those keys varies from one terminal
emulation program and terminal emulation mode to another.

.B Extend editing mode

Pressing the
.I <Esc>
key enters the extended editing mode which mimics
certain features of the "vi" editor commonly available on many 
UNIX-like operating systems.  The extended mode also permits scrolling
through the recent command history, thus repeating and editing
previously issued commands.

Once the extended editing mode is invoked, the editor operates
either in command or in text entry mode.  The text entry mode 
can be entered by issuing one of the appropriate commands (see below)
and can be suspended by pressing the
.I <Esc>
key.
Optionally, each command may be prepended by a numeric value defining
how many times that command should be repeated.

Navigation commands:
.TP
.B k
Recall the previous line from the command history buffer.
.TP
.B j
Recall the next line from the command history buffer.
.TP
.B h
Move the cursor left one character.
.TP
.B l
Move the cursor right one character.
.TP
.B b
Move the cursor to the begining of the previous word.
.TP
.B w
Move the cursor to the begining of the next word.
.TP
.B 0
Move the cursor to the begining of the line.
.TP
.B $
Move the cursor to the end of the line.
.TP
Text entry commands:
.TP
.B a
Append new text,
.I after
the cursor.
.TP
.B i
Insert new text,
.I before
the cursor.
.TP
.B A
Append new text to the end of the line.
.TP
.B I
Insert new text at the beginning of the line.
.TP
.B r
Replace a single character at the current cursor position.
.TP
.B s
Substitute a character at the current cursor position with new text.
.TP
.B C
Clear text from the current cursor position to the end of the line
and append new text.
.TP
.B R
Replace text starting from the current cursor position.
.TP
Text deletion commands:
.TP
.B x
Delete the character the cursor is on,
and place the deleted character into an auxiliary clipboard buffer.
.TP
.B d<nav>
Delete characters in the direction defined by the
.I nav
key, which may be any of
.B h
,
.B l
,
.B b
,
.B w
,
.B 0
or
.B $
(see above for the description of the navigation commands).
Deleted character(s) are placed into an auxiliary clipboard buffer.
.TP
Copy and paste commands:
.TP
.B y<nav>
Copy characters in the direction defined by the
.I nav
key into an auxiliary buffer.  The set of valid navigation keys
is the same as for the
.B d
command.
.TP
.B p
Paste the contents of the auxiliary buffer
.I after
the current cursor position.
.TP
.B P
Paste the contents of the auxiliary buffer
.I before
the current cursor position.
.TP
Miscellaneous commands:
.TP
.B ~
Reverse the case of the character at the current cursor position, and
advance the cursor one character to the right.
.TP
.B u
Undo the last change.

.SH COMMANDS
.TP
.BR REM \ or \ ' \  {\ text\ }
An arbitrary comment, ignored by the interpreter.
.TP
.B LET var = exp
Evaluate the expression
.I exp
and assign its a value to the variable
.IR var .
The LET keyword may be omitted for brevity.
.TP
.BR PRINT \ or \ ? \ \  {\ arg,\  ...\  }
.TP
.B PRINT #f { arg, ... }
Prints a variable number of arguments to the terminal.
The arguments may be separated either by commas or
semi-colons.  A comma indicates that the cursor will be
advanced to the next tab stop (typically 8 characters).
The output may be directed to a file if a file descriptor
preceeded by a hash sign is provided as the first argument.
.TP
.B INPUT { #f, } var1 { , ... } 
.TP
.B INPUT \&"txt\&"; var1 { , ... }
Input data from a terminal or from a file and store it into named
variable(s). An optional message string
.I txt
can be displayed before processing input from the controlling terminal.
.TP
.B LINPUT { #f, } var 
.TP
.B LINPUT \&"txt\&"; var
Input a whole line (ignoring separators) into a single string variable
.IR var .
.TP
.B GOTO lnum
Unconditionally jump to the program line specified by
.IR lnum .
.TP
.B GOSUB lnum
Jump to a subrutine at line
.IR lnum ,
saving the current line number on the return stack.
.TP
.B ON expr GOTO lnum1 { , lnum2 ... }
Jump to the line number selected from the list following the
GOTO statement and indexed by the value of
.IR expr .
If
.I expr
is less than or equal to zero or exceeds the number of elements
in the list then proceed to the next instruction.
.TP
.B ON expr GOSUB lnum1 { , lnum2 ... }
Jump to a subroutine at the line number selected from the list following the
GOTOSUB statement indexed by the value of
.IR expr ,
saving the current line number on the return stack.
If
.I expr
is less than or equal to zero or exceeds the number of elements
in the list then proceed to the next instruction.
.TP
.B RETURN
Return from a subroutine, resuming execution at the line following
the last GOSUB command.
.TP
.B IF expr THEN commands { ELSE commands }
Evaluate the expression
.I expr
and if the result is non-zero execute command(s) following
the THEN keyword.
Optionally, an ELSE keyword may be included followed by command(s)
to be executed if the expression
.I expr
evaluates to zero.
A line line number may be specified instead of
a command following either or both THEN and ELSE keywords,
which implies a GOTO to the requested line.
.TP
.B FOR var = expr1 TO expr2 { STEP expr3 }
Beginning of a FOR loop.  The value of variable
.I var
will be initialized to the value of
.I expr1
and will be increased on each subsequent loop iteration
either by one or by the value of
.I expr3
if the optional STEP keyword is specified.
Looping will continue as long as the value of
.I var
is less then or equal to
.IR expr2 .
The loop is always executed at least once.
.TP
.B NEXT { var, ... }
Increase the value of variable 
.I var
either by one or by the alternative STEP specified in the
corresponding FOR statement.  If the value of the variable
exceeds the limit specified in the FOR statement, advance
to the next program line, otherwise jump to the line
immediately following the FOR statement.
Multiple variable names may be specified following the NEXT
keyword, in which case each one is processed only after the
completion of the inner loop.  Alternatively, the NEXT keyword
may be used with no arguments, in which case it implies closure
of the first unterminated FOR loop.
.TP
.B WHILE expr
Beginning of a WHILE - WEND loop. The body of the loop is executed
as long as the value of the expression
.I expr
evaluates to a non-zero value.  The expression
.I expr
is evaluated
.I before
the body of the loop gets executed.
.TP
.B WEND
Terminate the body of a WHILE loop.
.TP
.B REPEAT
Begining of a REPEAT - UNTIL loop.
.TP
.B UNTIL expr
Terminating statement of a REPEAT - UNTIL loop.
The body of the loop is executed as long as the value of the expression
.I expr
evaluates to a non-zero value.  The expression
.I expr
is evaluated
.I after
the body of the loop gets executed, so the commands inside the loop
are guaranteed to be executed at least once.
.TP
.B DATA constant { , constant ... }
Declare comma separated numerical or string
constants to be used by READ statements. 
DATA statements are not permitted inside IF - THEN - ELSE constructs.
.TP
.B READ var { , var ... }
Read string or numeric constant(s) from DATA statements embedded
in the program and assign them to variable(s) provided as arguments.
.TP
.B RESTORE { lnum }
Restore the pointer for reading DATA constants to the start of the
program, so that the constants can be READ again. If an
optional line number
.I lnum
is provided then the restore occurs
from the start of that line. If no DATA statements are
found then the RESTORE command searches from the start of the
program.
.TP
.B DIM var(d1 {, d2} {, d3}) {, ... }
Declare and allocate memory for a list of arrays (string or
arithmetic).  A maximum of three subscripts can be used.
All arrays must be declared via DIM before use.
.TP
.B BASE 0 | 1
Specify the starting index for arrays, which may be either zero or one.
.TP
.B OPEN stringexp { FOR INPUT|OUTPUT|APPEND|TERMINAL } AS exp
Open a file named
.I stringexp
to be used with file descriptor
.IR exp .
Output mode is implied, hence the 'FOR OUTPUT' option may be
omitted for brevity.
.TP
.B CLOSE exp
Close a file with file descriptor
.IR exp .
Releases the file descriptor and flushes out all buffered data.
.TP
.B ON ERROR GOTO lnum
Register an error handler routine at line
.IR lnum .
.TP
.B RESUME { lnum }
Return from an error handler.  Optionally, do not return to the
instruction which triggered the error, but to the line
.IR lnum .
.TP
.B DEF FNname{ ( var {,var } ) } = exp
Define a function.
.TP
.B MID$(stringval, exp { ,exp} ) = stringexp
Assign
.I stringexp
to
.I stringval
starting at
.I exp1
and finishing at
.IR exp2 .
.TP
.B CLS
Clear the terminal screen.
.TP
.B POKE addr, byte
Write a
.I byte
into a memory location at
.IR addr .
.TP
.B RANDOM
Reseed the random number generator.
.TP
.B END
Terminate program execution and return to the interactive mode
command prompt.
.TP
.B STOP
Terminate program execution and return to the interactive mode
command prompt.
Unlike the END command, the STOP command prints a message,
and permits the execution to be resumed via the CONT command.
.TP
.B CONT
Continue execution of a program which has been
halted by a STOP command or via <ctrl-C>.
.TP
.B CLEAR
Clear all variables.
.TP
.B NEW
Close all files, clear all variables, and clear program memory.
.TP
.B RUN { l }
Execute the currently loaded program.  An optional numeric argument
can be provided indicating a line number from which the program
execution will begin.
All variables are cleared and all currently open files
are closed prior to starting program execution.
.TP
.B LIST { start } { - end }
Display the content of the program memory to the controlling terminal.
Optionally a range of line numbers to display may be specified.
.TP
.B EDIT lnum
Edit an existing line of the program text.
.TP
.B AUTO { start {, step } }
Perform auto line numbering so that a program can be typed in without
entering line numbers.  An optional
.I start
line number and an increment
.I step
may also be specified.
.TP
.B DELETE start - end
Delete a range of lines between
.I start
and
.I end
inclusively.
.TP
.B BYE
Terminate the execution of the interpreter,
closing all files.
.TP
.B SAVE stringexp
Save the current program to a named file.
.TP
.B LOAD stringexp
Close all files and clear all variables, then load a program from
file
.IR stringexp .
.TP
.B MERGE stringexp
Read a program from file
.I stringexp
end merge it with the current program stored in main memory.
Program lines in current program which have the same line numbers
as the lines from the file
.I stringexp
will be silently overwritten.
.TP
.B CHAIN stringexp
Load a program from file
.IR stringexp ,
and execute it immediately.  Numeric variables are preserved
but all arrays and strings are cleared.
.TP
.B ERROR exp
Execute the given error sequence, which may be useful for
debugging of error handler routines.
.TP
.B DIR { path }
List directory contents of the current directory, or 
of the target
.I path
if provided.
.TP
.B CD path
Change current directory to
.IR path .
.TP
.B PWD
Print the current directory.
.TP
.B KILL path
Remove a file or directory pointed to by
.IR path .
Directories must be empty for the reques to succeed.
.TP
.B MKDIR path
Create a directory at
.IR path .
.TP
.B COPY src_path, dst_path
Copy a file from
.I src_path
to
.IR dst_path .
If the destination file already exists it will be silently overwritten.
.TP
.B RENAME from_path, to_path
Rename a file named
.I from_path
to
.IR to_path .
.TP
.B MORE path
Display an ASCII file pointed to by
.I path
to the controlling terminal line by line, pausing each page (24 lines)
for terminal input.  Pressing
.I <space> 
displays another page, whereas pressing
.I <enter>
or
.I <j>
displays a single new line.  The pager may be interrupted by pressing
.I <q>
or
.IR <ctrl+c> .
.TP
.B VIDMODE expr
Choose one of four possible video output modes, identified by integer
values in range from 0 to 3.  Mode 0 uses a fixed 8-bit colour pallete,
whereas mode 1 uses a fixed 16-bit pallete for each of
512 (W) x 288 (H) pixels in a fixed-size video display matrix.
Mode 2 displays a static
test image, while mode 3 completely turns off the video output.
Modes 2 and 3 do not consume any memory bandwidth, hence permit
the CPU to operate at full speed, whereas activating the framebuffer
(modes 0 and 1) may have a noticeable impact on program execution
performance.  By default the display is turned off (mode 3).
.TP
.B COLOR fgcolor {, bgcolor}
Select a color to be used in subsequent graphics operations.  An optional
background color which is only used when displaying text
may be specified as a second argument.  Colors may be specified
in three different formats.  If the argument
provided is a string and the first character of the argument is "#",
then next six characters are interpreted as hexadecimal values
in form of
.IR RRGGBB ,
corresponding to 8-bit values of red, green and blue components.
Alternatively, if the argument is a string and its first character is
not "#", then the color key is searched for in the following pallete:
.IR black ,
.IR gray ,
.IR gray25 ,
.IR gray50 ,
.IR gray75 ,
.IR white ,
.IR red ,
.IR green ,
.IR navy ,
.IR blue ,
.IR teal ,
.IR lime ,
.IR cyan ,
.IR indigo ,
.IR maroon ,
.IR purple ,
.IR olive ,
.IR brown ,
.IR violet ,
.IR khaki ,
.IR magenta ,
.IR orange ,
.IR pink ,
.IR yellow .
Finally, a color may be specified as a numeric value, which will be
interpreted differently depending on the pallete in use (8-bit or
16-bit).
.TP
.B PLOT x0, y0 {, x1, y1 ... }
Draw a single pixel at coordinates
.IR (x0,y0) .
If additional coordinates are provided then continue drawing lines
to coordinates corresponding to further argument pairs.
.TP
.B LINETO x0, y0 {, x1, y1 ... }
Draw a line from the last cursor position to a pixel at coordinates
.IR (x0,y0) .
If additional coordinates are provided then continue drawing lines
to coordinates corresponding to further argument pairs.
.TP
.B RECTANGLE x0, y0, x1, y1 {, fill}
Draw a border of a rectangle defined by the provided coordinates.
If an optional argument
.I fill
is provided and its value is non-zero, then the entire region
encompassed by the rectangle is filled with current color.
.TP
.B CIRCLE x, y, r {, fill}
Draw a circle at
.IR x ,
.I y
with radius
.IR r .
If an optional argument
.I fill
is provided and its value is non-zero, then the entire region
encompassed by the circle is filled with current color.
.TP
.B TEXT x, y, stringexpr {, scale_x {, scale_y} }
Draw text
.I stringexpr
at
.IR x ,
.IR y .
Optional arguments
.I scale_x
and
.I scale_y
may be specified to increase the size of the font.
.TP
.B LOADJPG path
Load a JPEG image from a file pointed to by
.IR path
to the framebuffer.
The size of the image may not exceed 512 by 288 pixels.
.SH FUNCTIONS
.TP
.B MIN(x, ...)
Returns the minimum value among all of the provided arguments.
.TP
.B MAX(x, ... )
Returns the max value among all of the provided arguments.
.TP
.B ABS(x)
Returns the absolute value of x.
.TP
.B SGN(x)
Returns the sign of a number. It's value is 1
if greater than zero , zero if equal to zero. -1 if negative.
.TP
.B INT(x)
Return the integer part of x.
.TP
.B SQRT(x)
Returns the square root of x.
.TP
.B LOG(x)
Returns the natural logarithm of x.
.TP
.B LOG10(x)
Returns the logarithm in base 10 of x.
.TP
.B EXP(x)
Returns e^x. e=2.7182818..
.TP
.B SIN(x) COS(x) TAN(x) ASIN(x) ACOS(x) ATAN(x)
Trignometric functions.
.TP
.B SINH(x) COSH(x) TANH(x) ASINH(x) ACOSH(x) ATANH(x)
Hyperbolic functions.
.TP
.B RND
Returns an integer random number between 1 and 32767.
.TP
.B RND(x)
If x is zero returns a random number between
0 and 1 otherwise returns an integer random number
between 1 and INT(x).
.TP
.B PEEK(x)
Returns the value of a byte from memory at address x.
.TP
.B MID$(a$,i,j)
Returns the part of a$ between the i'th and
j'th positions. If the second parameter is not
specified then the string is taken between the start
value and the end of the string.
.TP
.B RIGHT$(a$,j)
Returns the right j characters of a$.
.TP
.B LEFT$(a$,j)
Returns the left j characters of a$.
.TP
.B STRING$(a$,j)
Returns a$ repeated j times.
.TP
.B ERMSG$(j)
Returns the j'th error message.
.TP
.B CHR$(j)
Returns the ascii character corresponding to
the value of j.
.TP
.B STR$(j)
Returns a string representation corresponding
to j. This is similar but not the same as what can
printed out.
.TP
.B SPACE$(j)
Returns a string of j spaces
.TP
.B GET$(f)
Returns one character from file f. If f is zero
use the terminal. Returns a zero lenght string on cntl-c
.TP
.B LEN(a$)
Returns the length of string a$.
.TP
.B VAL(a$)
Returns the value of the number specified by the string.
.TP
.B ASC(a$)
Returns the ascii code for the first element of a$.
.TP
.B INSTR(a$,b$,c)
Returns the starting position that a$ is in
b$, starting from the optional c'th position.
.TP
.B EOF(f)
Returns true if the file specified by f has reached the end of the file.
.TP
.B POSN(f)
Returns the current printing position in the
file. If f is zero then it is the printing position of
the terminal.
.TP
.B EVAL(a$)
Evaluates the expression defined by the string a$.
e.g. EVAL("12") returns the value 12.
.TP
.B PI
Returns the value of pi. = 3.141592653589...
.TP
.B ERL
Returns the line number of the last error.
Zero if error was in immeadiate mode.
.TP
.B ERR
Returns the error code of the last error.
.TP
.B TIM
Returns a numeric value for the number of seconds since system startup.
.SH MATHEMATICAL OPERATORS
        ^               exponentiation
        *               multiplication
        /               division
        MOD             remainder
        +               addition
        -               subtraction

        AND             bitwise and
        OR              bitwise or
        XOR             bitwise exclusive or
        NOT             bitwise not

        <=              less than or equal
        <>              not equal to
        >=              greater than or equal
        =               equal
        >               greater than
        <               less than

Certain assignments can be specified in an abbreviated form:
        a += b          a = a + b
        a -= b          a = a - b
        a *= b          a = a * b
        a /= b          a = a / b
.SH EXPRESSION SYNTAX
        stringexp  ::= string | string + stringexp
        string     ::= qstring | stringvar | stringfunc
        qstrings   ::= "any char" | `any char`
                        N.B. strings with nothing after them on the
                             line do not need the terminating quote
        stringvar  ::= numbvar$ | numbvar$[ dim1 { ,dim2 {, dim3 } } ]
        stringfunc ::= chr$(val) | mid$(stringexp, val {,val} )
                        | date$ | right$(stringexp, val)
                        | left$(stringexp, val) | ermsg$(val)
                        | str$( val) | space$(val)
                        | string$(stringexp, val) | get$( 0 | fval )

        val        ::= term | term sep val
                        | not val | - val
        term       ::= numb | valfunc | numbvr
                        | stringexp csep stringexp
        numb       ::= digit | digit digit+
                        | digit* . digit*
                        | digit* e {+ | -} digit+
                        | digit* . digit* e {+ | -} digit+
        digit      ::= 0 1 2 3 4 5 6 7 8 9
        numbvr     ::= numbvar | subsc
        numbvar    ::= lett | lett alpha+
        subsc      ::= numbvar( val {, val { ,val } } )
        sep        ::= + - * /  ^ and or xor | csep
        csep       ::= <> > < >= <= =
        valfunc    ::= sgn(val) | len(stringexp)
                        | abs(val) | val(stringexp)
                        | asc(stringexp) | eof(fval)
                        | posn( 0 | fval) | sqrt(val)
                        | instr(stringexp, val { ,val} )
                        | log(val) | exp(val) | eval(stringexp)
                        | int(val) | peek(val) | rnd
                        | rnd(val) | usrfunc | pi
                        | erl | err | tim
        usrfunc    ::=  fn/numbvar { (val { , val { , val } } ) }
        fval       ::= val with value between 1-9
.SH ULX2S FPGA BOARD
ULX2S is a compact-factor FPGA prototyping board designed primarily
as an affordable teaching aid to be used in basic digital design
courses and to be easily embeddable in more complex digital systems.
A pre-built
FPGA bitstream with a system-on-a-chip configuration centered around
a 32-bit RISC CPU core operating at 81.25 MHz also permits execution
of various software packages, including a BASIC interpreter.

An on-board SPI Flash memory chip can be
accessed from BASIC as disk drive
.IR \&"0:\&" .
In standard
configuration the SPI Flash drive also hosts the executable binary of
the BASIC interpreter which is automatically loaded by the ROM
bootloader when the board is powered up.  Data can be read from the
on-board Flash drive at rates of up to 10 MBytes/s, while writing
speed is limited to around 185 KBytes/s.  The SPI Flash chip does
not provide any wear-leveling machinery, so write access should be
moderately exercised to avoid exceeding the chip's declared 
endurance of around 100.000 write cycles.

A MicroSD, MicroSDHC or MicroSDXC card formatted with the FAT32
file system inserted in the MicroSD slot should be accessible as disk
drive
.IR \&"1:\&" .
Read speeds of up to 4.5 MBytes/s and write speeds of
up to 2.5 MBytes/s may be sustained depending on card type,
data layout and access patterns.

The ULX2S board has 1 MByte of static RAM mapped by the SoC
configuration to 0x80000000, which is also the address where the
bootloader loads the BASIC interpreter.  The linear video framebuffer
region is mapped to 0x800b0000 and depending on the video pallete
selected (8- or 16-bit) it occupies either 147456 or 294912 bytes
of SRAM.

All I/O ports are memory-mapped to a region starting at 0xff000000,
which permits I/O ports to be addressed using small negative integers.
The following ports may be safely accessed from BASIC using
PEEK and POKE:
.TP
.B GPIO
.TP
.I -256 (0xffffff00): GPIO data, byte 0 (input / output)
.IP
.PD 0
bit 0: pin j1_2
.IP
bit 1: pin j1_3
.IP
bit 2: pin j1_4
.IP
bit 3: pin j1_8
.IP
bit 4: pin j1_9
.IP
bit 5: pin j1_13
.IP
bit 6: pin j1_14
.IP
bit 7: pin j1_15
.PD 1
.TP
.I -255 (0xffffff01): GPIO data, byte 1 (input / output)
.IP
.PD 0
bit 0: pin j1_16
.IP
bit 1: pin j1_17
.IP
bit 2: pin j1_18
.IP
bit 3: pin j1_19
.IP
bit 4: pin j1_20
.IP
bit 5: pin j1_21
.IP
bit 6: pin j1_22
.IP
bit 7: pin j1_23
.PD 1
.TP
.I -254 (0xffffff02): GPIO data, byte 2 (input / output)
.IP
.PD 0
bit 0: pin j2_2
.IP
bit 1: pin j2_3
.IP
bit 2: pin j2_4
.IP
bit 3: pin j2_5
.IP
bit 4: pin j2_6
.IP
bit 5: pin j2_7
.IP
bit 6: pin j2_8
.IP
bit 7: pin j2_9
.PD 1
.TP
.I -253 (0xffffff03): GPIO data, byte 3 (input / output)
.IP
.PD 0
bit 0: pin j2_10
.IP
bit 1: pin j2_11
.IP
bit 2: pin j2_12
.IP
bit 3: pin j2_13
.IP
bit 4: pin j2_16
.IP
bit 5 to 7: not connected
.PD 1
.TP
.I -252 (0xffffff04): GPIO control, byte 0 (output only)
.TP
.I -251 (0xffffff05): GPIO control, byte 1 (output only)
.TP
.I -250 (0xffffff06): GPIO control, byte 2 (output only)
.TP
.I -249 (0xffffff07): GPIO control, byte 3 (output only)

.RE
.RS
.RS
A total of 29 pins on DIL connectors J1 and J2 can be controlled
via GPIO ports.  GPIO data ports can be both read and written to,
while bits in the corresponding control ports determine whether
each pin is configured as input (control bit cleared) or as
output (control bit set).  By default all pins are configured as
input.
.TP
.B LEDS, BUTTONS AND SWITCHES
.TP
.I -240 (0xffffff10): pushbuttons / LEDs (input / output)
.IP
.PD 0
bit 0: btn_right (input)
.IP
bit 1: bnt_left (input)
.IP
bit 2: btn_down (input)
.IP
bit 3: btn_up (input)
.IP
bit 4: btn_center (input)
.IP
bits 0 to 7: led_0 to led_7 (output)
.PD 1
.TP
.I -239 (0xffffff11): DIL switches (input)
.IP
.PD 0
bits 0 to 3: sw_0 to sw_3 (input)
.IP
bits 4 to 7: not connected
.PD 1
.RE
.RS
.SH DIAGNOSTICS
When the interpreter discovers an error it will call
an error trapping routine. The errors can be caught by
the user program using the on-error feature. If no error
trapping routine has been supplied a message is printed
with the corresponding line number.
.SH BUGS
The RENUMBER command fails to properly track and update goto targets
hidden inside IF .. THEN .. ELSE constructs.

REPEAT - UNTIL loops inside functions, procedures or nested inside
other loops apparently do not work.

The MOD operator is implemented using
.IR fmod(3) ,
so the result may or may not include a fractional part.
.SH DISCLAIMER
THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
SUCH DAMAGE.
.SH AUTHORS
Phil Cockcroft created the Rabbit BASIC in early 1980's while he was at
University College, London.  He released the source code to the
Public Domain in 1986 and continued to further improve and maintain it
until mid-1990's.
In 2013. Marko Zec added features specific to the ULX2S FPGA board, such
as file management and framebuffer routines, and rewrote this
manual page.
