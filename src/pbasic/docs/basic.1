.TH BASIC 1
.SH DESCRIPTION
.B Rabbit BASIC
is an interpreter for the BASIC programming language. See below
for current commands recognised. 
At startup, the interpreter attempts to load and execute a program
called autoexec.bat from the root directory of the on-board Flash drive.
If the startup program is not found or its execution terminates,
a line editor is invoked which accepts and processes
all subsequent input from the terminal.
.SH EDITING
To get special ASCII characters into a line use constructs like
\\n \\a etc. which will get ctrl-n and ctrl-a into the line.
.SH COMMANDS
.HP 6
END
.br
Terminate program execution and return to the interactive mode
command prompt.
.HP 6
RUN { l }
.br
Execute the currently loaded program.  An optional numeric argument
can be provided indicating a line number from which the program
execution will begin.
All variables are cleared and all currently open files
are closed prior to the beginning of program execution.
.HP 6
GOTO l
.br
Jumps to the specified line number.
.HP 6
LET x = exp
.br
Assign a value to a variable.  If the LET keyword may be omitted.
.HP 6
LIST
.br
lists the whole program
.HP 6
LIST 1-2
.br
lists lines 1 to 2
.HP 6
LIST -100
.br
lists all lines up to 100
.HP 6
LIST 1
.br
lists only line 1
.HP 6
LIST 1-
.br
lists line 1 onwards
.br
This command will display the entire or the selected portion
of the current program onto the terminal.
.HP 6
PRINT or '?' { arg, ... }
.HP 6
PRINT #f { arg, ... }
.br
Prints a variable number of arguments to the terminal.
The arguments may be separated either by commas or
semi-colons.  A comma indicates that the cursor will be
advanced to the next tab stop (usually 8 or 16 characters).
The output may be directed to a file if a file descriptor
preceeded by a hash sign is provided as the first argument.
.HP 6
REM or `'
.br
An arbitrary comment.
.HP 6
STOP
.br
Stops program execution and returns to the interactive command prompt.
Functionally equivalent to the END command, with two exceptions:
the STOP command prints a message, and permits the execution to
be continued via the CONT command.
.HP 6
FOR var = expr1 TO expr2 { STEP expr }
.br
Beginning of a FOR loop.  The value of variable
var will be initialized to expr1 and will be increased
by one on each subsequent loop iteration, and loping will
continue as long as var is less then or equal to expr2.
The loop is always executed at least once.
.HP 6
NEXT { x { , y } }
.br
End of a FOR loop. If terminal conditions are met then
execution continues from the
next statement, otherwise return to end of the
corresponding for statement. The NEXT statement does not need a
parameter if this is the case the most recently
activated loop is used. If there are multiple
parameters then each one is only checked after the
completion of the inner loop.
.HP 6
GOSUB l
.br
Jump to a subrutine ar line l, saving current line number on
the return stack.
.HP 6
RETURN
.br
Return from a subroutine, resuming execution at a line following
the last GOSUB command.
.HP 6
READ var { , var }
.br
Read a string or numeric data item from DATA statements embedded
in the program and assign it to variable(s) provided as arguments.
.HP 6
DATA object { , object }
.br
Declare comma separated constant data items to be used by
READ statements. 
DATA statements are not permitted inside IF - THEN - ELSE constructs.
.HP 6
RESTORE { l }
.br
Restore the data pointer to the start of the
file, so that the data can be read again. If an
optional line number is provided then the restore occurs
from the start of that line. If no data statements are
found then the restore is from the start of the
program.
.HP 6
IF exp THEN statement { ELSE statement }
.br
If the condition is true
then the commands after the THEN keyword are executed.  A
line line number may be specified instead of a command, which
implies a GOTO to the requested line. If the
condition is false then the statement after the optional ELSE
keyword is evaluated and executed.
.HP 6
DIM var(d,d,d) { , var(d) }
.br
Declare and allocate memory for a list of arrays (string or
arithmetic).   A maximum of three subscripts can be used.
All arrays must be declared via DIM before use.
.HP 6
EXIT , BYE , QUIT
.br
Terminate the execution of the interpreter,
closing all files.
.HP 6
DELETE l - l
.br
Delete a specified range of lines. If they
are not found then no lines will be deleted.
.HP 6
EDIT l
.br
Edit an existing line of the program text.  Editing may be
terminated via ctrl-c, discarding all changes.
.HP 6
INPUT { #f, } 
.br
INPUT "prompt";
.br
Input data from a terminal or from a file. If the
input is from the terminal then a prompt message can
also be added.
.HP 6
CLEAR exp
.br
Clear all variables then allocate the amount
of string space specified by the second parameter.
.HP 6
SAVE stringexp
.br
Save the current program to a named file.
.HP 6
LOAD stringexp
.br
Load a program from the named file. All
variables are cleared.
.HP 6
NEW { exp }
.br
Wipe the program from core. All files are
closed and the interpreter is reset to its inital
state. If a parameter is given then that is the number
of file buffers that are allocated.
.HP 6
RESUME { l }
.br
Return from an error trap. If a parameter is
given then the return is made to that line. An error
trap is set up by the "ON ERROR GOTO" statement.
.HP 6
RANDOM
.br
Reseed the random number generator.
.HP 6
ON exp GOTO l { , l}
.HP 6
ON exp GOSUB
.HP 6
ON ERROR GOTO l
.br
This command will execute either a goto or a
gosub to a specified line number. The linenumber is
specified by the value of the statement and the
linenumber is taken from the list of line numbers that
is given.
If the error format is used, only one
linenumber is required. This is the line where a jump
is performed to if an error occurs.
.HP 6
ERROR exp
.br
Execute the given error sequence. Useful for
debugging of error trap routines.
.HP 6
AUTO { l { ,l } }
.br
Perform auto line numbering so that a program
can be typed in without having to bother about
linenumbers. An optional start and increment can also
be specified.
.HP 6
CLS
.br
Clear the terminals screen.
.HP 6
BASE 0 | 1
.br
Specify the starting index for arrays. This
can have a value of either zero or one.
.HP 6
POKE exp, exp
.br
Write a byte into a memory location.
.HP 6
OPEN stringexp
{ FOR INPUT|OUTPUT|APPEND|TERMINAL } AS exp
.br
Open a file for input or output. This command
can be used to specify whether the file is to be read
or writen to. A file cannot be opened for writing if
the file is already open. If the mode is TERMINAL then
it will believe that it is talking to a terminal. (No
buffering. Open for reading and writing.) If the option
is 'FOR OUTPUT' it may be ommitted.
.HP 6
CLOSE exp
.br
Close a file. Releases the file descriptor
and flushes out all stored data.
.HP 6
MERGE stringexp
.br
Merge two files together. If there is a line
in the file with the same linenumber as in the program
then that line is replaced by the new one. All other
lines are inserted into the file.
.HP 6
CHAIN stringexp
.br
Read in a program, then start to execute it.
All simple variables are kept but all arrays and
strings are cleared. The size of the string space is
kept the same.
.HP 6
DEF FNname{ ( var {,var } ) } = exp
.br
Define a user defineable function.
.HP 6
LINPUT
.br
Identical to input but ignores seperators.
.HP 6
MID$(stringval, exp { ,exp} ) = stringexp
.br
Assign stringexp to stringval starting at exp1
and finishing at exp2.
.HP 6
CONT
.br
Continue execution of a program which has been
halted by a stop statement or by ctrl-c.
.HP 6
WHILE exp
.br
Beginning of a WHILE loop. The loop is repeated
until exp is false. If exp is false at the start then do
not execute the loop at all. A while loop must be
terminated by a WEND statement.
.HP 6
WEND
.br
Terminating statement of a WHILE loop. Only one
WEND is allowed for each WHILE.
.HP 6
REPEAT
.br
Start statement for a REPEAT - UNTIL loop. This
type of loop will always be executed at least once.
.HP 6
UNTIL exp
.br
The terminating statement of a REPEAT - UNTIL
loop. The loop terminates when exp is true.
.PP
String functions Available
.br
.HP 6
MID$(a$,i,j)
.br
Returns the part of a$ between the i'th and
j'th positions. If the second parameter is not
specified then the string is taken between the start
value and the end of the string.
.HP 6
RIGHT$(a$,j)
.br
Returns the right j characters of a$.
.HP 6
LEFT$(a$,j)
.br
Returns the left j characters of a$.
.HP 6
STRING$(a$,j)
.br
Returns a$ repeated j times.
.HP 6
ERMSG$(j)
.br
Returns the j'th error message.
.HP 6
CHR$(j)
.br
Returns the ascii character corresponding to
the value of j.
.HP 6
STR$(j)
.br
Returns a string representation corresponding
to j. This is similar but not the same as what can
printed out.
.HP 6
SPACE$(j)
.br
Returns a string of j spaces
.HP 6
GET$(f)
.br
Returns one character from file f. If f is zero
use the terminal. Returns a zero lenght string on cntl-c
.HP 6
DATE$
.br
returns a string coresponding to the current
date. ( Same string as printed out when logging on. ).
.PP
Maths functions Available:-
.HP 6
SGN(x)
.br
Returns the sign of a number. It's value is 1
if greater than zero , zero if equal to zero. -1 if
negative.
.HP 6
LEN(a$)
.br
Returns the length of string a$.
.HP 6
ABS(x)
.br
Returns the absolute value of x.
.HP 6
INT(x)
.br
than x.
.HP 6
VAL(a$)
.br
Returns the value of the number specified by
the string.
.HP 6
ASC(a$)
.br
Returns the ascii code for the first element
of a$.
.HP 6
INSTR(a$,b$,c)
.br
Returns the starting position that a$ is in
b$, starting from the optional c'th position.
.HP 6
EOF(f)
.br
Returns true if the file specified by f has
reached the end of the file.
.HP 6
POSN(f)
.br
Returns the current printing position in the
file. If f is zero then it is the printing position of
the terminal.
.HP 6
SQRT(x)
.br
Returns the square root of X.
.HP 6
LOG(x)
.br
Returns the natural logarithm of x.
.HP 6
EXP(x)
.br
Returns e^x. e=2.7182818..
.HP 6
EVAL(a$)
.br
Evaluates a$.
e.g. EVAL("12") returns the value 12.
.HP 6
RND
.br
Returns a random number between 1 and 32767.
.HP 6
RND(x)
.br
If x is zero returns a random number between
0 and 1 otherwise returns a random number
between 1 and int(x).
.HP 6
PEEK(x)
.br
Returns the value of the byte at address x.
.HP 6
SIN(x)
.br
.HP 6
COS(x)
.br
.HP 6
ATAN(x)
.br
Trignometric functions. (May not yet be
implemented).
.HP 6
PI
.br
Returns the value of pi. = 3.141592653589...
.HP 6
ERL
.br
Returns the line number of the last error.
Zero if error was in immeadiate mode.
.HP 6
ERR
.br
Returns the error code of the last error.
.HP 6
TIM
.br
Returns a numeric value for the number of
seconds since
1:1:1970 i.e. the value of the Unix clock.
.PP
.B Mathematical Operators:
.HP 6
	The  following  mathematical  operators   are
accepted.
.nf
             ^               exponentiation
             *               multiplication
             /               division
             MOD             remainder
             +               addition
             -               subtraction

     bitwise operators:-
        for real values non-zero is true,
             AND             bitwise and
             OR              bitwise or
             XOR             bitwise exclusive or
             NOT             bitwise not

     comparison operators:-
             <=              less than or equal
             <>              not equal to
             >=              greater than or equal
             =               equal
             >               greater than
             <               less than

      Assignment statements can also have the form
        a +=  b     a -=  b     a *=  b    a /=  b
      Which have similar meanings to C's interpretation
.fi
.PP
.nf
EXPRESSION SYNTAX

        stringexp  ::= string | string + stringexp
        string     ::= qstring | stringvar | stringfunc
        qstrings   ::= "any char" | `any char`
                        N.B. strings with nothing after them on the
                             line do not need the terminating quote
        stringvar  ::= numbvar$ | numbvar$[ dim1 { ,dim2 {, dim3 } } ]
        stringfunc ::= chr$(val) | mid$(stringexp, val {,val} )
                        | date$ | right$(stringexp, val)
                        | left$(stringexp, val) | ermsg$(val)
                        | str$( val) | space$(val)
                        | string$(stringexp, val) | get$( 0 | fval )

        val        ::= term | term sep val
                        | not val | - val
        term       ::= numb | valfunc | numbvr
                        | stringexp csep stringexp
        numb       ::= digit | digit digit+
                        | digit* . digit*
                        | digit* e {+ | -} digit+
                        | digit* . digit* e {+ | -} digit+
        digit      ::= 0 1 2 3 4 5 6 7 8 9
        numbvr     ::= numbvar | subsc
        numbvar    ::= lett | lett alpha+
        subsc      ::= numbvar( val {, val { ,val } } )
        sep        ::= + - * /  ^ and or xor | csep
        csep       ::= <> > < >= <= =
        valfunc    ::= sgn(val) | len(stringexp)
                        | abs(val) | val(stringexp)
                        | asc(stringexp) | eof(fval)
                        | posn( 0 | fval) | sqrt(val)
                        | instr(stringexp, val { ,val} )
                        | log(val) | exp(val) | eval(stringexp)
                        | int(val) | peek(val) | rnd
                        | rnd(val) | usrfunc | pi
                        | erl | err | tim
        usrfunc    ::=  fn/numbvar { (val { , val { , val } } ) }
        fval       ::= val with value between 1-9
.SH DIAGNOSTICS
When the interpreter discovers an error it will call
an error trapping routine. The errors can be caught by
the user program using the on-error feature. If no error
trapping routine has been supplied a message is printed
with the corresponding line number.
.SH BUGS
The RENUMBER command fails to properly track and update goto targets
hidden inside IF .. THEN .. ELSE constructs.

The MOD function sometimes returns non-integer values.

REPEAT - UNTIL loops inside functions, procedures or nested inside
other loops apparently do not work.
.SH AUTHORS
Phil Cockcroft created the Rabbit BASIC in early 1980's while he was at
University College, London.  He released the source code to the
Public Domain in 1986 and continued to further improve and maintain it
until mid-1990's.  Features specific to the ULX2S FPGA board, such
as file management and framebuffer routines, were added by
Marko Zec in 2013.
