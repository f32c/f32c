.TH BASIC 1
.SH DESCRIPTION
.I Rabbit BASIC
is an interpreter for a dialect of the BASIC programming language
loosely modelled around the historic Dartmouth BASIC.
The interpreter operates either in interactive mode, which permits
issuing individual commands or editing the current program, or
in run mode, executing the program loaded into the main memory.
At startup, the interpreter attempts to load and execute a program
called
.I autoexec.bat
from the root directory of the on-board Flash drive.
If the startup program can not be found or its execution terminates,
an interactive line editor is invoked which accepts and processes
all subsequent input from the controlling terminal.
.SH INTERACTIVE MODE
All lines prepended with a numeric line identifier are assumed
to be a part of a program and will be stored into the main memory at a
position corresponding to the specified line number, and will not be
further evaluated or interpreted until program execution begins.
Conversely, lines entered without a line number will be interpreted and
executed immediately.

Editing a line may be aborted at any time by pressing
.IR <ctrl-C> .
The contents of the line buffer may be redrawn by pressing
.IR <ctrl-R>
which can come handy particularly when editing lines longer then
terminal width (usually 80 characters).
Characters at the end of the line may be deleted
by pressing either the delete key or
.IR <ctrl-H> .
Neither cursors nor other
special keys, such as Home, End, PgUp or PgDown can be used in
editing mode, since mapping of those keys varies from one terminal
emulation program and terminal emulation mode to another.

.B Extend editing mode

Pressing the ESC key enters the extended editing mode which mimics
certain features of the "vi" editor commonly available on many 
UNIX-like operating systems.  The extended mode also permits scrolling
through the recent command history, thus repeating and editing
previously issued commands.

Once the extended editing mode is invoked, the editor operates
either in command or in text entry mode.  The text entry mode 
can be entered by issuing one of the appropriate commands (see below)
and can be suspended by pressing the ESC key.
Optionally, each command may be prepended by a numeric value defining
how many times that command should be repeated.

Navigation commands:
.TP
.B k
Recall the previous line from the command history buffer.
.TP
.B j
Recall the next line from the command history buffer.
.TP
.B h
Move the cursor left one character.
.TP
.B l
Move the cursor right one character.
.TP
.B b
Move the cursor to the begining of the previous word.
.TP
.B w
Move the cursor to the begining of the next word.
.TP
.B 0
Move the cursor to the begining of the line.
.TP
.B $
Move the cursor to the end of the line.
.TP
Text entry commands:
.TP
.B a
Append new text,
.I after
the cursor.
.TP
.B i
Insert new text,
.I before
the cursor.
.TP
.B A
Append new text to the end of the line.
.TP
.B I
Insert new text at the beginning of the line.
.TP
.B r
Replace a single character at the current cursor position.
.TP
.B s
Substitute a character at the current cursor position with new text.
.TP
.B C
Clear text from the current cursor position to the end of the line
and append new text.
.TP
.B R
Replace text starting from the current cursor position.
.TP
Text deletion commands:
.TP
.B x
Delete the character the cursor is on,
and place the deleted character into an auxiliary clipboard buffer.
.TP
.B d<nav>
Delete characters in the direction defined by the
.I nav
key, which may be any of
.B h
,
.B l
,
.B b
,
.B w
,
.B 0
or
.B $
(see above for the description of the navigation commands).
Deleted character(s) are placed into an auxiliary clipboard buffer.
.TP
Copy and paste commands:
.TP
.B y<nav>
Copy characters in the direction defined by the
.I nav
key into an auxiliary buffer.  The set of valid navigation keys
is the same as for the
.B d
command.
.TP
.B p
Paste the contents of the auxiliary buffer
.I after
the current cursor position.
.TP
.B P
Paste the contents of the auxiliary buffer
.I before
the current cursor position.
.TP
Miscellaneous commands:
.TP
.B ~
Reverse the case of the character at the current cursor position, and
advance the cursor one character to the right.
.TP
.B u
Undo the last change.

.SH BASIC COMMANDS
.TP
.BR REM \ or
.B '
An arbitrary comment.
.TP
.B LET var = exp
Evaluate the expression
.I exp
and assign its a value to the variable
.IR var .
The LET keyword may be omitted for brevity.
.TP
.BR PRINT
or
.B '?' { arg, ... }
.TP
.B PRINT #f { arg, ... }
Prints a variable number of arguments to the terminal.
The arguments may be separated either by commas or
semi-colons.  A comma indicates that the cursor will be
advanced to the next tab stop (typically 8 characters).
The output may be directed to a file if a file descriptor
preceeded by a hash sign is provided as the first argument.
.TP
.B INPUT { #f, } var1 { , ... } 
.TP
.B INPUT \&"prompt\&"; var1 { , ... }
Input data from a terminal or from a file and store it to named
variable(s). A prompt message can be displayed when reading input
from the controlling terminal.
.TP
.B GOTO l
Jump to the specified line number.
.TP
.B GOSUB l
Jump to a subrutine ar line
.IR l , saving current line number on the return stack.
.TP
.B RETURN
Return from a subroutine, resuming execution at a line following
the last GOSUB command.
.TP
.B END
Terminate program execution and return to the interactive mode
command prompt.
.TP
.B STOP
Stops program execution and returns to the interactive command prompt.
Unlike the END command, the STOP command prints a message,
and permits the execution to be continued via the CONT command.
.TP
.B RUN { l }
Execute the currently loaded program.  An optional numeric argument
can be provided indicating a line number from which the program
execution will begin.
All variables are cleared and all currently open files
are closed prior to the beginning of program execution.
.TP
.B LIST { start } { - end }
XXX

TODO: from here on...

.TP
FOR var = expr1 TO expr2 { STEP expr }
.br
Beginning of a FOR loop.  The value of variable
var will be initialized to expr1 and will be increased
by one on each subsequent loop iteration, and loping will
continue as long as var is less then or equal to expr2.
The loop is always executed at least once.
.HP 6
NEXT { x { , y } }
.br
End of a FOR loop. If terminal conditions are met then
execution continues from the
next statement, otherwise return to end of the
corresponding for statement. The NEXT statement does not need a
parameter if this is the case the most recently
activated loop is used. If there are multiple
parameters then each one is only checked after the
completion of the inner loop.
READ var { , var }
.br
Read a string or numeric data item from DATA statements embedded
in the program and assign it to variable(s) provided as arguments.
.HP 6
DATA object { , object }
.br
Declare comma separated constant data items to be used by
READ statements. 
DATA statements are not permitted inside IF - THEN - ELSE constructs.
.HP 6
RESTORE { l }
.br
Restore the data pointer to the start of the
file, so that the data can be read again. If an
optional line number is provided then the restore occurs
from the start of that line. If no data statements are
found then the restore is from the start of the
program.
.HP 6
IF exp THEN statement { ELSE statement }
.br
If the condition is true
then the commands after the THEN keyword are executed.  A
line line number may be specified instead of a command, which
implies a GOTO to the requested line. If the
condition is false then the statement after the optional ELSE
keyword is evaluated and executed.
.HP 6
DIM var(d,d,d) { , var(d) }
.br
Declare and allocate memory for a list of arrays (string or
arithmetic).   A maximum of three subscripts can be used.
All arrays must be declared via DIM before use.
.HP 6
EXIT , BYE , QUIT
.br
Terminate the execution of the interpreter,
closing all files.
.HP 6
DELETE l - l
.br
Delete a specified range of lines. If they
are not found then no lines will be deleted.
.HP 6
EDIT l
.br
Edit an existing line of the program text.
.HP 6
.HP 6
CLEAR exp
.br
Clear all variables then allocate the amount
of string space specified by the second parameter.
.HP 6
SAVE stringexp
.br
Save the current program to a named file.
.HP 6
LOAD stringexp
.br
Load a program from the named file. All
variables are cleared.
.HP 6
NEW { exp }
.br
Wipe the program from core. All files are
closed and the interpreter is reset to its inital
state. If a parameter is given then that is the number
of file buffers that are allocated.
.HP 6
RESUME { l }
.br
Return from an error trap. If a parameter is
given then the return is made to that line. An error
trap is set up by the "ON ERROR GOTO" statement.
.HP 6
RANDOM
.br
Reseed the random number generator.
.HP 6
ON exp GOTO l { , l}
.HP 6
ON exp GOSUB
.HP 6
ON ERROR GOTO l
.br
This command will execute either a goto or a
gosub to a specified line number. The linenumber is
specified by the value of the statement and the
linenumber is taken from the list of line numbers that
is given.
If the error format is used, only one
linenumber is required. This is the line where a jump
is performed to if an error occurs.
.HP 6
ERROR exp
.br
Execute the given error sequence. Useful for
debugging of error trap routines.
.HP 6
AUTO { l { ,l } }
.br
Perform auto line numbering so that a program
can be typed in without having to bother about
linenumbers. An optional start and increment can also
be specified.
.HP 6
CLS
.br
Clear the terminals screen.
.HP 6
BASE 0 | 1
.br
Specify the starting index for arrays. This
can have a value of either zero or one.
.HP 6
POKE exp, exp
.br
Write a byte into a memory location.
.HP 6
OPEN stringexp
{ FOR INPUT|OUTPUT|APPEND|TERMINAL } AS exp
.br
Open a file for input or output. This command
can be used to specify whether the file is to be read
or writen to. A file cannot be opened for writing if
the file is already open. If the mode is TERMINAL then
it will believe that it is talking to a terminal. (No
buffering. Open for reading and writing.) If the option
is 'FOR OUTPUT' it may be ommitted.
.HP 6
CLOSE exp
.br
Close a file. Releases the file descriptor
and flushes out all stored data.
.HP 6
MERGE stringexp
.br
Merge two files together. If there is a line
in the file with the same linenumber as in the program
then that line is replaced by the new one. All other
lines are inserted into the file.
.HP 6
CHAIN stringexp
.br
Read in a program, then start to execute it.
All simple variables are kept but all arrays and
strings are cleared. The size of the string space is
kept the same.
.HP 6
DEF FNname{ ( var {,var } ) } = exp
.br
Define a user defineable function.
.HP 6
LINPUT
.br
Identical to input but ignores seperators.
.HP 6
MID$(stringval, exp { ,exp} ) = stringexp
.br
Assign stringexp to stringval starting at exp1
and finishing at exp2.
.HP 6
CONT
.br
Continue execution of a program which has been
halted by a stop statement or by <ctrl-C>.
.HP 6
WHILE exp
.br
Beginning of a WHILE loop. The loop is repeated
until exp is false. If exp is false at the start then do
not execute the loop at all. A while loop must be
terminated by a WEND statement.
.HP 6
WEND
.br
Terminating statement of a WHILE loop. Only one
WEND is allowed for each WHILE.
.HP 6
REPEAT
.br
Start statement for a REPEAT - UNTIL loop. This
type of loop will always be executed at least once.
.HP 6
UNTIL exp
.br
The terminating statement of a REPEAT - UNTIL
loop. The loop terminates when exp is true.
.PP
String functions Available
.br
.HP 6
MID$(a$,i,j)
.br
Returns the part of a$ between the i'th and
j'th positions. If the second parameter is not
specified then the string is taken between the start
value and the end of the string.
.HP 6
RIGHT$(a$,j)
.br
Returns the right j characters of a$.
.HP 6
LEFT$(a$,j)
.br
Returns the left j characters of a$.
.HP 6
STRING$(a$,j)
.br
Returns a$ repeated j times.
.HP 6
ERMSG$(j)
.br
Returns the j'th error message.
.HP 6
CHR$(j)
.br
Returns the ascii character corresponding to
the value of j.
.HP 6
STR$(j)
.br
Returns a string representation corresponding
to j. This is similar but not the same as what can
printed out.
.HP 6
SPACE$(j)
.br
Returns a string of j spaces
.HP 6
GET$(f)
.br
Returns one character from file f. If f is zero
use the terminal. Returns a zero lenght string on cntl-c
.HP 6
DATE$
.br
returns a string coresponding to the current
date. ( Same string as printed out when logging on. ).
.PP
Maths functions Available:-
.HP 6
SGN(x)
.br
Returns the sign of a number. It's value is 1
if greater than zero , zero if equal to zero. -1 if
negative.
.HP 6
LEN(a$)
.br
Returns the length of string a$.
.HP 6
ABS(x)
.br
Returns the absolute value of x.
.HP 6
INT(x)
.br
than x.
.HP 6
VAL(a$)
.br
Returns the value of the number specified by
the string.
.HP 6
ASC(a$)
.br
Returns the ascii code for the first element
of a$.
.HP 6
INSTR(a$,b$,c)
.br
Returns the starting position that a$ is in
b$, starting from the optional c'th position.
.HP 6
EOF(f)
.br
Returns true if the file specified by f has
reached the end of the file.
.HP 6
POSN(f)
.br
Returns the current printing position in the
file. If f is zero then it is the printing position of
the terminal.
.HP 6
SQRT(x)
.br
Returns the square root of X.
.HP 6
LOG(x)
.br
Returns the natural logarithm of x.
.HP 6
EXP(x)
.br
Returns e^x. e=2.7182818..
.HP 6
EVAL(a$)
.br
Evaluates a$.
e.g. EVAL("12") returns the value 12.
.HP 6
RND
.br
Returns a random number between 1 and 32767.
.HP 6
RND(x)
.br
If x is zero returns a random number between
0 and 1 otherwise returns a random number
between 1 and int(x).
.HP 6
PEEK(x)
.br
Returns the value of the byte at address x.
.HP 6
SIN(x)
.br
.HP 6
COS(x)
.br
.HP 6
ATAN(x)
.br
Trignometric functions. (May not yet be
implemented).
.HP 6
PI
.br
Returns the value of pi. = 3.141592653589...
.HP 6
ERL
.br
Returns the line number of the last error.
Zero if error was in immeadiate mode.
.HP 6
ERR
.br
Returns the error code of the last error.
.HP 6
TIM
.br
Returns a numeric value for the number of
seconds since
1:1:1970 i.e. the value of the Unix clock.
.PP
.B Mathematical Operators:
.HP 6
	The  following  mathematical  operators   are
accepted.
.nf
             ^               exponentiation
             *               multiplication
             /               division
             MOD             remainder
             +               addition
             -               subtraction

     bitwise operators:-
        for real values non-zero is true,
             AND             bitwise and
             OR              bitwise or
             XOR             bitwise exclusive or
             NOT             bitwise not

     comparison operators:-
             <=              less than or equal
             <>              not equal to
             >=              greater than or equal
             =               equal
             >               greater than
             <               less than

      Assignment statements can also have the form
        a +=  b     a -=  b     a *=  b    a /=  b
      Which have similar meanings to C's interpretation
.fi
.PP
.nf
EXPRESSION SYNTAX

        stringexp  ::= string | string + stringexp
        string     ::= qstring | stringvar | stringfunc
        qstrings   ::= "any char" | `any char`
                        N.B. strings with nothing after them on the
                             line do not need the terminating quote
        stringvar  ::= numbvar$ | numbvar$[ dim1 { ,dim2 {, dim3 } } ]
        stringfunc ::= chr$(val) | mid$(stringexp, val {,val} )
                        | date$ | right$(stringexp, val)
                        | left$(stringexp, val) | ermsg$(val)
                        | str$( val) | space$(val)
                        | string$(stringexp, val) | get$( 0 | fval )

        val        ::= term | term sep val
                        | not val | - val
        term       ::= numb | valfunc | numbvr
                        | stringexp csep stringexp
        numb       ::= digit | digit digit+
                        | digit* . digit*
                        | digit* e {+ | -} digit+
                        | digit* . digit* e {+ | -} digit+
        digit      ::= 0 1 2 3 4 5 6 7 8 9
        numbvr     ::= numbvar | subsc
        numbvar    ::= lett | lett alpha+
        subsc      ::= numbvar( val {, val { ,val } } )
        sep        ::= + - * /  ^ and or xor | csep
        csep       ::= <> > < >= <= =
        valfunc    ::= sgn(val) | len(stringexp)
                        | abs(val) | val(stringexp)
                        | asc(stringexp) | eof(fval)
                        | posn( 0 | fval) | sqrt(val)
                        | instr(stringexp, val { ,val} )
                        | log(val) | exp(val) | eval(stringexp)
                        | int(val) | peek(val) | rnd
                        | rnd(val) | usrfunc | pi
                        | erl | err | tim
        usrfunc    ::=  fn/numbvar { (val { , val { , val } } ) }
        fval       ::= val with value between 1-9
.SH DIAGNOSTICS
When the interpreter discovers an error it will call
an error trapping routine. The errors can be caught by
the user program using the on-error feature. If no error
trapping routine has been supplied a message is printed
with the corresponding line number.
.SH BUGS
The RENUMBER command fails to properly track and update goto targets
hidden inside IF .. THEN .. ELSE constructs.

The MOD function sometimes returns non-integer values.

REPEAT - UNTIL loops inside functions, procedures or nested inside
other loops apparently do not work.
.SH AUTHORS
Phil Cockcroft created the Rabbit BASIC in early 1980's while he was at
University College, London.  He released the source code to the
Public Domain in 1986 and continued to further improve and maintain it
until mid-1990's.  Features specific to the ULX2S FPGA board, such
as file management and framebuffer routines, were added by
Marko Zec in 2013.
