--
-- Copyright 2008, 2010 University of Zagreb, Croatia.
--
-- Redistribution and use in source and binary forms, with or without
-- modification, are permitted provided that the following conditions
-- are met:
-- 1. Redistributions of source code must retain the above copyright
--    notice, this list of conditions and the following disclaimer.
-- 2. Redistributions in binary form must reproduce the above copyright
--    notice, this list of conditions and the following disclaimer in the
--    documentation and/or other materials provided with the distribution.
--
-- THIS SOFTWARE IS PROVIDED BY AUTHOR AND CONTRIBUTORS ``AS IS'' AND
-- ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
-- IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
-- ARE DISCLAIMED.  IN NO EVENT SHALL AUTHOR OR CONTRIBUTORS BE LIABLE
-- FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
-- DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
-- OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
-- HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
-- LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
-- OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
-- SUCH DAMAGE.
--
--

-- $Id$

library IEEE;
use IEEE.STD_LOGIC_1164.ALL;
use IEEE.STD_LOGIC_ARITH.ALL;
use IEEE.STD_LOGIC_UNSIGNED.ALL;


entity glue is
	generic(
		clk_multiplier: integer := 5; -- base clk is 10.00 MHz
		mult_enable: string := "false";
		branch_prediction: string := "none"; -- none, static
		register_technology: string := "xilinx_ram16x1d";
		-- debugging
		reg_trace: string := "true";
		bus_trace: string := "true"; -- XXX reduce clock rate if bus_trace enabled!
		imem_trace: string := "false";
		dmem_trace: string := "false";
		lcd_debug: string := "false";
		serial_debug: string := "true"
	);
	port (
		clk_50m: in std_logic;
		lcd_db: out std_logic_vector(7 downto 0);
		lcd_e, lcd_rs, lcd_rw: out std_logic;
		led: out std_logic_vector(7 downto 0);
		rot_a, rot_b, rot_center, btn_south, btn_north, btn_east, btn_west: in std_logic;
		sw: in std_logic_vector(3 downto 0);
		rs232_dce_txd: out std_logic;
		rs232_dce_rxd: in std_logic;
		j20_io: out std_logic_vector(4 downto 1)
	);
end glue;

architecture Behavioral of glue is
	signal clk, gated_clk, slowclk: std_logic;
	signal imem_addr: std_logic_vector(31 downto 2);
	signal imem_data_read: std_logic_vector(31 downto 0);
	signal imem_addr_strobe, imem_data_ready: std_logic;
	signal dmem_addr: std_logic_vector(31 downto 2);
	signal dmem_addr_strobe, dmem_bram_enable, dmem_data_ready: std_logic;
	signal dmem_byte_we: std_logic_vector(3 downto 0);
	signal dmem_to_cpu, cpu_to_dmem: std_logic_vector(31 downto 0);
	signal io_to_cpu, final_to_cpu: std_logic_vector(31 downto 0);

   -- I/O
	signal led_reg: std_logic_vector(7 downto 0);
	signal lcd_data: std_logic_vector(7 downto 0);
	signal lcd_ctrl: std_logic_vector(1 downto 0);
	signal tsc: std_logic_vector(31 downto 0);

	-- debugging only
	signal clk_key: std_logic;
	signal buffered_keys: std_logic_vector(8 downto 0);
	signal rot_left, rot_right: std_logic;
	signal pipeline_status: std_logic_vector(7 downto 0);
	signal lcd_debug_data: std_logic_vector(7 downto 0);
	signal lcd_debug_rs, lcd_debug_e: std_logic;
	signal reg_trace_data_unbuf, reg_trace_data: std_logic_vector(31 downto 0);
	signal trace_selector, trace_selector_cpu, trace_selector_mem: std_logic;
	signal trace_addr, trace_addr2: std_logic_vector(5 downto 0);
	signal trace_data, trace_data2: std_logic_vector(31 downto 0);
	signal trace_mem_addr: std_logic_vector(19 downto 2);
	signal trace_mem_data, xxx: std_logic_vector(31 downto 0);
	signal imem_data_debug, imem_data_debug2: std_logic_vector(31 downto 0);
	signal dmem_data_debug, dmem_data_debug2: std_logic_vector(31 downto 0);
begin


	-- instruction / data BRAMs
	dmem_bram_enable <= dmem_addr_strobe when dmem_addr(31 downto 28) /= "1110"
		else '0';

	-- I/O port map:
	-- 0xe******0:	(1B, WR) LED
	-- 0xe******4:	(4B, RD) TSC
	-- 0xe******8:	(1B, WR) LCD data
	-- 0xe******c:	(1B, WR) LCD ctrl
	-- I/O write access:
	process(gated_clk)
	begin
		if falling_edge(gated_clk) then
			tsc <= tsc + 1;
			if dmem_addr(31 downto 28) = "1110" and dmem_addr_strobe = '1' then
				if dmem_byte_we /= "0000" then
					if dmem_addr(3 downto 2) = "00" then
						led_reg <= cpu_to_dmem(7 downto 0);
					elsif dmem_addr(3 downto 2) = "10" then
						lcd_data <= cpu_to_dmem(7 downto 0);
					elsif dmem_addr(3 downto 2) = "11" then
						lcd_ctrl <= cpu_to_dmem(1 downto 0);
					end if;
				end if;
			end if;
		end if;
	end process;

	io_to_cpu <= tsc;
	final_to_cpu <= io_to_cpu when dmem_addr(31 downto 28) = "1110"
		else dmem_to_cpu;
	
	led <= led_reg when reg_trace /= "true" or sw(2) = '1'
		else pipeline_status;
	lcd_db <= lcd_data when reg_trace /= "true" or sw(3) = '1'
		else lcd_debug_data;
	lcd_rs <= lcd_ctrl(0) when reg_trace /= "true" or sw(3) = '1'
		else lcd_debug_rs;
	lcd_e <= lcd_ctrl(1) when reg_trace /= "true" or sw(3) = '1'
		else lcd_debug_e;
	lcd_rw <= '0';
	
	-- a DLL clock synthesizer
   clkgen: entity clkgen
		generic map(
			clk_multiplier => clk_multiplier
		)
		port map(
			clk_in => clk_50m, clk_out => clk,
			clk_out_gated => gated_clk, clk_out_slow => slowclk,
			key => clk_key, sel => sw(1 downto 0)
		);
	
	-- conditionally link debugging signals
	trace_selector_cpu <= trace_selector when reg_trace = "true" and bus_trace = "true"
		else '1' when bus_trace = "true" else '0';
	trace_selector_mem <= trace_selector when imem_trace = "true" and dmem_trace = "true"
		else '1' when dmem_trace = "true" else '0';
	trace_addr <= trace_addr2 when reg_trace = "true" or bus_trace = "true"
		else "000000";
	trace_data2 <= trace_data when reg_trace = "true" or bus_trace = "true"
		else x"00000000";
	imem_data_debug2 <= imem_data_debug when imem_trace = "true"
		else x"00000000";
	dmem_data_debug2 <= dmem_data_debug when dmem_trace = "true"
		else x"00000000";
	
	-- mux for memory debug interface
	trace_mem_data <= imem_data_debug2 when trace_selector_mem = '0' else dmem_data_debug2;
	
   -- debugging design instance - LCD + control knob / buttons
	debug_lcd:
	if lcd_debug = "true" and (reg_trace = "true" or bus_trace = "true" or imem_trace = "true" or dmem_trace = "true") generate
	begin
	debug_lcd: entity lcd_debug
		generic map(reg_trace => reg_trace, bus_trace => bus_trace,
			imem_trace => imem_trace, dmem_trace => dmem_trace)
		port map(
			slowclk => slowclk,
			lcd_db => lcd_debug_data, lcd_rs => lcd_debug_rs,
			lcd_e => lcd_debug_e,
			rot_a => rot_a, rot_b =>rot_b, rot_center => rot_center,
			btn_south => btn_south, btn_north => btn_north,
			btn_east => btn_east, btn_west => btn_west, sw => sw,
			buffered_keys => buffered_keys,
			left => rot_left, right => rot_right,
			trace_selector => trace_selector,
			trace_addr => trace_addr2(4 downto 0),
			trace_data => trace_data2,
			trace_mem_addr => trace_mem_addr,
			trace_mem_data => trace_mem_data
		);
	end generate; -- lcd_debug
 
	-- debugging design instance - serial port + control knob / buttons
	debug_serial:
	if serial_debug = "true" and (reg_trace = "true" or bus_trace = "true" or imem_trace = "true" or dmem_trace = "true") generate
	begin
	debug_serial: entity serial_debug
		port map(
			clk_50m => clk_50m,
			rs232_txd => rs232_dce_txd,
			trace_addr => trace_addr2,
			trace_data => xxx
		);
	end generate; -- serial_debug

	xxx <= x"000000" & "00" & trace_addr2;
	
	-- manual clk keying by btn_south or by rotating the knob while btn_south depressed
	clk_key <= buffered_keys(2) xor (buffered_keys(2) and (rot_left xor rot_right));
	
	-- drive J20_IO pins
	j20_io <= trace_addr2(4 downto 1);

	
	nodebug:
	if not (reg_trace = "true" or bus_trace = "true" or imem_trace = "true" or dmem_trace = "true") generate
	begin
		clk_key <= '1'; -- clk selector
	end generate; -- nodebug
	
end Behavioral;
